/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export interface CoinInfoWrapper {
  parentCoinInfo: string
  puzzleHash: string
  amount: string
}
export interface CoinSpendInfoWrapper {
  coin: CoinInfoWrapper
  puzzleReveal: string
  solution: string
  realData: boolean
  parsingMethod: string
  offset: number
  createdCoins: Array<CoinInfoWrapper>
}
export interface ParsedBlockWrapper {
  height: number
  weight: string
  headerHash: string
  timestamp?: number
  coinAdditions: Array<CoinInfoWrapper>
  coinRemovals: Array<CoinInfoWrapper>
  coinSpends: Array<CoinSpendInfoWrapper>
  coinCreations: Array<CoinInfoWrapper>
  hasTransactionsGenerator: boolean
  generatorSize?: number
}
export interface GeneratorBlockInfoWrapper {
  prevHeaderHash: string
  transactionsGenerator?: string
  transactionsGeneratorRefList: Array<number>
}
export interface BlockHeightInfoWrapper {
  height: number
  isTransactionBlock: boolean
}
export const enum DatabaseType {
  Sqlite = 0,
  Postgres = 1
}
export interface Block {
  height: number
  weight: number
  headerHash: Array<number>
  timestamp: string
}
export interface Spend {
  coinId: string
  puzzleHash?: Array<number>
  puzzleReveal?: Array<number>
  solutionHash?: Array<number>
  solution?: Array<number>
  spentBlock: number
}
export interface DnsDiscoveryErrorInfo {
  message: string
  errorType: string
}
export interface PeerAddressJs {
  host: string
  port: number
  isIpv6: boolean
  displayAddress: string
}
export interface DiscoveryResultJs {
  ipv4Peers: Array<PeerAddressJs>
  ipv6Peers: Array<PeerAddressJs>
  totalCount: number
}
export interface AddressResult {
  addresses: Array<string>
  count: number
}
export interface EventTypes {
  blockReceived: string
  peerConnected: string
  peerDisconnected: string
}
export declare function getEventTypes(): EventTypes
export interface PeerConnectedEvent {
  peerId: string
  host: string
  port: number
}
export interface PeerDisconnectedEvent {
  peerId: string
  host: string
  port: number
  message?: string
}
export interface BlockReceivedEvent {
  peerId: string
  height: number
  weight: string
  headerHash: string
  timestamp: number
  coinAdditions: Array<CoinRecord>
  coinRemovals: Array<CoinRecord>
  coinSpends: Array<CoinSpend>
  coinCreations: Array<CoinRecord>
  hasTransactionsGenerator: boolean
  generatorSize: number
}
export interface CoinRecord {
  parentCoinInfo: string
  puzzleHash: string
  amount: string
}
export interface CoinSpend {
  coin: CoinRecord
  puzzleReveal: string
  solution: string
  offset: number
}
export interface NewPeakHeightEvent {
  oldPeak?: number
  newPeak: number
  peerId: string
}
export declare function initTracing(): void
export declare class ChiaBlockParser {
  constructor()
  parseFullBlockFromBytes(blockBytes: Buffer): ParsedBlockWrapper
  parseFullBlockFromHex(blockHex: string): ParsedBlockWrapper
  extractGeneratorFromBlockBytes(blockBytes: Buffer): string | null
  getHeightAndTxStatusFromBlockBytes(blockBytes: Buffer): BlockHeightInfoWrapper
  parseBlockInfoFromBytes(blockBytes: Buffer): GeneratorBlockInfoWrapper
}
export declare class BlockchainNamespace {
  createBlock(block: Block): Promise<void>
  getBlockByHeight(height: number): Promise<Block | null>
  getBlocksRange(startHeight: number, endHeight: number, page: number, pageSize: number): Promise<Array<Block>>
  deleteBlock(height: number): Promise<void>
  createSpend(spend: Spend): Promise<void>
  getSpendByCoinId(coinId: string): Promise<Spend | null>
  deleteSpend(coinId: string): Promise<void>
}
export declare class AnalyticsNamespace {
  getPuzzleStats(): Promise<string>
  getSolutionStats(): Promise<string>
  getBalanceStats(): Promise<string>
  // Address Analysis Functions
  getAddressProfile(puzzleHashHex: string): Promise<string>
  getAddressTransactionHistory(puzzleHashHex: string, page: number, pageSize: number): Promise<string>
  getAddressCoinFlow(puzzleHashHex: string): Promise<string>
  getAddressSpendingBehavior(puzzleHashHex: string): Promise<string>
  getAddressPeers(puzzleHashHex: string, page: number, pageSize: number): Promise<string>
  getAddressRiskAssessment(puzzleHashHex: string): Promise<string>
  getAddressActivityTimeline(puzzleHashHex: string, daysBack: number): Promise<string>
  // CAT Analytics Functions
  getCatTokenAnalytics(assetId: string): Promise<string>
  getCatDistributionAnalysis(assetId: string, page: number, pageSize: number): Promise<string>
  getCatTradingVelocity(assetId: string, daysBack: number): Promise<string>
  getCatHolderBehavior(assetId: string, page: number, pageSize: number): Promise<string>
  getCatTokenComparison(page: number, pageSize: number): Promise<string>
  getCatLiquidityAnalysis(assetId: string): Promise<string>
  // NFT Analytics Functions
  getNftCollectionAnalytics(collectionId: string): Promise<string>
  getNftOwnershipConcentration(collectionId: string, page: number, pageSize: number): Promise<string>
  getNftTradingVelocity(collectionId: string, daysBack: number): Promise<string>
  getNftRarityAnalysis(collectionId: string, page: number, pageSize: number): Promise<string>
  getNftCollectionComparison(page: number, pageSize: number): Promise<string>
  getNftCreatorAnalytics(creatorPuzzleHashHex: string): Promise<string>
}
export declare class AssetsNamespace {
  getCatBalances(ownerPuzzleHash: string, page: number, pageSize: number): Promise<string>
  getNftsByOwner(ownerPuzzleHash: string, collectionId: string | undefined | null, page: number, pageSize: number): Promise<string>
}
export declare class SystemNamespace {
  getSyncStatus(): Promise<string>
  getSystemPreferences(): Promise<string>
  setSystemPreference(key: string, value: string): Promise<void>
}
export declare class ChiaBlockDatabase {
  /** Create a new database instance */
  constructor()
  /** Initialize the database with a connection URL */
  init(databaseUrl: string): Promise<void>
  /** Initialize the database with explicit type */
  initWithType(databaseUrl: string, dbType: DatabaseType): Promise<void>
  /** Get the database type */
  getDatabaseType(): Promise<DatabaseType>
  /** Test database connection */
  testConnection(): Promise<boolean>
  /** Access to blockchain operations (blocks, coins, spends) */
  blockchain(): BlockchainNamespace
  /** Access to analytics operations (puzzles, solutions, balances) */
  analytics(): AnalyticsNamespace
  /** Access to asset operations (CATs, NFTs) */
  assets(): AssetsNamespace
  /** Access to system operations (sync status, preferences) */
  system(): SystemNamespace
  /** Execute a raw SQL query with optional parameters */
  executeRawQuery(query: string, params?: Array<string>): Promise<string>
  /** Close the database connection */
  close(): Promise<void>
}
export declare class DnsDiscoveryClient {
  /** Create a new DNS discovery client */
  constructor()
  /** Discover peers for Chia mainnet */
  discoverMainnetPeers(): Promise<DiscoveryResultJs>
  /** Discover peers for Chia testnet11 */
  discoverTestnet11Peers(): Promise<DiscoveryResultJs>
  /** Discover peers using custom introducers */
  discoverPeers(introducers: Array<string>, defaultPort: number): Promise<DiscoveryResultJs>
  /** Resolve IPv4 addresses (A records) for a hostname */
  resolveIpv4(hostname: string): Promise<AddressResult>
  /** Resolve IPv6 addresses (AAAA records) for a hostname */
  resolveIpv6(hostname: string): Promise<AddressResult>
  /** Resolve both IPv4 and IPv6 addresses for a hostname */
  resolveBoth(hostname: string, port: number): Promise<DiscoveryResultJs>
}
export declare class ChiaBlockListener {
  constructor()
  addPeer(host: string, port: number, networkId: string): string
  disconnectPeer(peerId: string): boolean
  disconnectAllPeers(): void
  getConnectedPeers(): Array<string>
  on(event: string, callback: (...args: any[]) => any): void
  off(event: string, callback: (...args: any[]) => any): void
  getBlockByHeight(peerId: string, height: number): BlockReceivedEvent
  getBlocksRange(peerId: string, startHeight: number, endHeight: number): Array<BlockReceivedEvent>
}
export declare class ChiaPeerPool {
  constructor()
  addPeer(host: string, port: number, networkId: string): Promise<string>
  getBlockByHeight(height: number): Promise<BlockReceivedEvent>
  removePeer(peerId: string): Promise<boolean>
  shutdown(): Promise<void>
  getConnectedPeers(): Promise<Array<string>>
  getPeakHeight(): Promise<number | null>
  on(event: string, callback: (...args: any[]) => any): void
  off(event: string, callback: (...args: any[]) => any): void
}
